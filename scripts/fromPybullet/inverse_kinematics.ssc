import BIDMach.rl.environments.bullet._
import BIDMach.rl.environments.Bullet
import BIDMach.rl.environments.Bullet._

val p = new Bullet;

var clid = p.connect(eCONNECT_GUI);
//var clid = p.connect(eCONNECT_SHARED_MEMORY);
if (!clid) p.connect(eCONNECT_DIRECT);

p.setPathPrefix("/code/bullet3/data/");
p.loadURDF("plane.urdf",row(0,0,-0.3f));

val kukaId = p.loadURDF("kuka_iiwa/model.urdf",row(0,0,0));
p.resetBasePositionAndOrientation(kukaId,row(0,0,0),Quaternion(1,0,0,0));
val kukaEndEffectorIndex = 6;
val numJoints = p.getNumJoints(kukaId);
	

// lower limits for null space
val ll=drow(-0.967,-2,-2.96,0.19,-2.96,-2.09,-3.05);
// upper limits for null space
val ul=drow(0.967,2,2.96,2.29,2.96,2.09,3.05);
// joint ranges for null space
val jr=drow(5.8,4,5.8,4,5.8,4,6);
// restposes for null space
val rp=drow(0,0,0,0.5*math.Pi,0,-math.Pi*0.5*0.66,0);
// joint damping coefficents
val jd=drow(0.1,0.1,0.1,0.1,0.1,0.1,0.1);

for (i <- 0 until numJoints) {
	p.resetJointState(kukaId,i,rp(i));
}

p.setGravity(0,0,0);
var t=0.0;
var prevPose=drow(0,0,0);
var prevPose1=drow(0,0,0);
var hasPrevPose = 0;
val useNullSpace = 0;

val useOrientation = 1;
// If we set useSimulation=0, it sets the arm pose to be the IK result directly without using dynamic control.
// This can be used to test the IK result accuracy.
val useSimulation = 1;
val useRealTimeSimulation = 1;
p.setRealTimeSimulation(useRealTimeSimulation>0);
// trailDuration is duration (in seconds) after debug lines will be removed automatically
// use 0 for no-removal
val trailDuration = 15;
var jointPoses:DMat = null;
var pos:DMat = null;
var ls:LinkState = null;
	
while (true) {
//for (ii <- 0 until 100) {
    if (useRealTimeSimulation > 0) {
	val dt = System.currentTimeMillis / 1000.0
	t = (dt/6.0)*2*math.Pi;
    } else {
	t=t+0.001;
    }

    if (useSimulation > 0 && useRealTimeSimulation==0) {
	p.stepSimulation();
    }

    for (i <- 0 until 1) {
	pos = drow(-0.4,0.2*math.cos(t),0+0.2*math.sin(t));
	// end effector points down, not up (in case useOrientation==1);
        val orn = DMat(getQuaternionFromEuler(row(0,-math.Pi.toFloat,0)));
	
	if (useNullSpace==1) {
	    if (useOrientation==1) {
		jointPoses = p.calculateInverseKinematics(kukaId, kukaEndEffectorIndex, pos, orn, ll, ul, jr, rp);
	    } else {
		jointPoses = p.calculateInverseKinematics(kukaId, kukaEndEffectorIndex, pos, lowerLimits=ll, upperLimits=ul, jointRanges=jr, restPoses=rp);
	    }
	} else {
	    if (useOrientation==1) {
		jointPoses = p.calculateInverseKinematics(kukaId, kukaEndEffectorIndex, pos, orn, jointDamping=jd);
	    } else {
		jointPoses = p.calculateInverseKinematics(kukaId, kukaEndEffectorIndex, pos);
	    }
	}
	
	if (useSimulation > 0) {
	    for (i <- 0 until numJoints) {
		p.setJointMotorControl(kukaId,jointIndex=i,controlMode=POSITION_CONTROL,targetPosition=jointPoses(i),targetVelocity=0,maxTorque=500,positionGain=0.03,velocityGain=1);
	    }
	} else {
	    // reset the joint state (ignoring all dynamics, not recommended to use during simulation)
	    for (i <- 0 until numJoints) {
		p.resetJointState(kukaId,i,jointPoses(i));
	    }
	}
    }

    ls = p.getLinkState(kukaId,kukaEndEffectorIndex);
    if (hasPrevPose > 0) {
	println("pos "+prevPose+","+pos);
	println("pos1 "+prevPose1+","+ls.worldLinkFramePosition);
	    //	p.addUserDebugLine(prevPose,pos,[0,0,0.3],1,trailDuration);
	    //	p.addUserDebugLine(prevPose1,ls[4],[1,0,0],1,trailDuration);
    }
    prevPose=pos;
    prevPose1=ls.worldLinkFramePosition;
    hasPrevPose = 1;
}
