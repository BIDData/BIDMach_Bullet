import BIDMach.rl.environments.bullet._
import BIDMach.rl.environments.Bullet
import BIDMach.rl.environments.Bullet._

val sim = new Bullet;
sim.connect(eCONNECT_DIRECT);

def getJointStates(robot:Int) = {
    sim.getJointStates(robot).unpack
};

def setJointPosition(robot:Int, position:DMat, kp:Double=1.0, kv:Double=0.3) = {
    val num_joints = sim.getNumJoints(robot);
    val zero_vec = dzeros(1, num_joints);
    val one_vec = dones(1, num_joints);
    if (position.length == num_joints) {
	sim.setJointMotorControlArray(robot, irow(0->num_joints), POSITION_CONTROL,
				      targetPositions=position, targetVelocities=zero_vec,
				      positionGains=kp * one_vec, velocityGains=kv * one_vec);
    } else {
	println("Positions length doesnt match numJoints");
    }
};

def multiplyJacobian(jacobian:DMat, vector:DMat) = {
    vector *^ jacobian;
};


val time_step = 0.001f;
val gravity_constant = -9.81f;
sim.resetSimulation();
sim.setTimeStep(time_step);
sim.setGravity(0, 0, gravity_constant);
sim.setPathPrefix("/code/bullet3/data/");
sim.loadURDF("plane.urdf",row(0,0,-0.3f));


val kukaId = sim.loadURDF("kuka_iiwa/model.urdf");
sim.resetBasePositionAndOrientation(kukaId,row(0,0,0),Quaternion.identity());
val kukaEndEffectorIndex = 6;
val numJoints = sim.getNumJoints(kukaId);
// Set a joint target for the position control and step the sim.
setJointPosition(kukaId, 0.1*dones(1,numJoints));
//sim.setJointMotorControl(kukaId,0,POSITION_CONTROL,0.1,0,100000,1,0.3);
sim.stepSimulation();
// Get the joint and link state directly from Bullet.
val (pos, vel, _, torq) = sim.getJointStates4(kukaId, irow(0->numJoints));
val result = sim.getLinkState(kukaId, kukaEndEffectorIndex, computeLinkVelocity=1, computeForwardKinematics=1);
// Get the Jacobians for the CoM of the end-effector link.
// Note that in this example com_rot = identity, and we would need to use com_rot.T * com_trn.
// The localPosition is always defined in terms of the link frame coordinates.
val com_trn = result.localInertialPosition;
    
val zero_vec = dzeros(1, numJoints);
val (jac_t, jac_r) = sim.calculateJacobian(kukaId, kukaEndEffectorIndex, com_trn, pos, zero_vec, zero_vec);

println ("Link linear velocity of CoM from getLinkState:")
println (result.worldLinearVelocity)
println ("Link linear velocity of CoM from linearJacobian * q_dot:")
println (multiplyJacobian(jac_t, vel))
println ("Link angular velocity of CoM from getLinkState:")
println (result.worldAngularVelocity)
println ("Link angular velocity of CoM from angularJacobian * q_dot:")
println (multiplyJacobian(jac_r, vel))

